/*
 MIT License

 Copyright (c) 2024 Carlos Caba√ßo Tojal

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 */

#ifndef PCL_AGGREGATOR_CORE_INTRASENSORMANAGER_H
#define PCL_AGGREGATOR_CORE_INTRASENSORMANAGER_H

#include <string>
#include <memory>
#include <set>
#include <queue>
#include <mutex>
#include <cmath>
#include <eigen3/Eigen/Dense>
#include <pcl/point_types.h>
#include <pcl/point_cloud.h>
#include <pcl/registration/icp.h>
#include <pcl_aggregator_core/entities/StampedPointCloud.h>
#include <pcl_aggregator_core/utils/Utils.h>
#include <thread>
#include <condition_variable>
#include <functional>

#define STREAM_ICP_MAX_CORRESPONDENCE_DISTANCE 0.2f
#define STREAM_ICP_MAX_ITERATIONS 10

#define STREAM_DOWNSAMPLING_LEAF_SIZE 0.1f

#define CONSUMER_TIMEOUT_MS 100

#define UNPROCESSED_CLOUD_MAX_QUEUE_LEN 10

#define NUM_INTRA_SENSOR_WORKERS 2

#define AGE_WATCHER_PERIOD_SECONDS 1

namespace pcl_aggregator::managers {

    /*! \brief Manager of a stream of PointClouds.
     *
     * Manages a stream of PointClouds coming from a single sensor.
     * For example, merges and ages the PointClouds captured by a single LiDAR.
     * Instances of this class are point cloud producers.
     *
     * */
    class IntraSensorManager {

        private:
            std::string topicName;
            /*! \brief Unique pointer to the merged PointCloud generated by this \manager. */
            std::unique_ptr<entities::StampedPointCloud> cloud = nullptr;
            /*! \brief Transform from the sensor frame to the robot base frame. */
            Eigen::Affine3d sensorTransform;
            /*! \brief Is the transform of the sensor to the robot frame set. */
            bool sensorTransformSet = false;

            /*! \brief A set containing the PointClouds managed by this class ordered and identified by timestamp. */
            std::set<std::unique_ptr<entities::StampedPointCloud>,
                entities::CompareStampedPointCloudPointers> clouds;

            /*! \brief Queue of PointClouds waiting for the transform to be set. */
            std::queue<std::unique_ptr<entities::StampedPointCloud>> cloudsNotTransformed;

            /*! \brief Queue of PointClouds to be processed and registered by the workers. */
            std::deque<std::unique_ptr<entities::StampedPointCloud>> cloudsNotRegistered;

            /*! \brief Vector of workers which process incoming point clouds. */
            std::vector<std::thread> workers;

            /*! \brief Flag used to signal workers to stop. */
            bool workersShouldStop = false;

            /*! \brief Mutex to clouds not processed. */
            std::mutex cloudsNotRegisteredMutex;

            /*! \brief Condition variable to clouds not processed. */
            std::condition_variable cloudsNotRegisteredCond;

            /*! \brief Maximum age points live for. After this time they will be removed. */
            double maxAge;

            /*! \brief Is the cloud being queried by the InterSensorManager? Used as condition. */
            bool cloudReady = true;

            /*! \brief Merged cloud access condition variable. */
            std::condition_variable cloudConditionVariable;

            /*! \brief Mutex to manage access to the merged PointCloud and point cloud set. */
            std::mutex cloudMutex;
            /*! \brief Mutex to manage access to the sensor transform. */
            std::mutex sensorTransformMutex;
            /*! \brief Mutex to manage access to the cloudsNotTransformed queue. */
            std::mutex cloudQueueMutex;

            /*! \brief Thread which monitors the current PointCloud's age. Started by the constructor. */
            std::thread maxAgeWatcherThread;
            /*!\brief Flag to determine if the age watcher thread should be stopped or not. */
            bool keepAgeWatcherAlive = true;

            /*! \brief Mutex controlling access to the statistics variables. */
            std::mutex statisticsMutex;

            /*! \brief Current average time needed to process a point cloud from being received to being output. */
            double avgRegistrationTimeMs = 0.0f;

            /*! \brief Variance of the time needed to process a point cloud from being received to being output. */
            double varRegistrationTimeMs = 0.0f;

            /*! \brief Number of samples contributing to the registration time statistics. */
            size_t registrationTimeSampleCount = 0;

            /*! \brief Callback function to call when a PointCloud ages older than maxAge.
             * May be useful to remove points from the InterSensorManager's PointCloud.
             *
             * @param label The label to remove
             */
            std::function<void(std::set<std::uint32_t> labels)> pointAgingCallback = nullptr;

            /*! \brief Callback function to call when the IntraSensorManager has a new PointCloud ready.
             * May be useful to add PointClouds to the
             */
            std::function<void(entities::StampedPointCloud cloud, std::string& sensorName)>
                    pointCloudReadyCallback = nullptr;

            /*! \brief Loop ran by the workers, taking jobs from the queue. Each worker runs this method. */
            void workersLoop();

            /*! \brief Loop ran by the age watcher. */
            void ageWatcherLoop();

            /*! \brief Compute the sensor transform. */
            void moveTransformPendingToQueue();

            void removePointCloud(std::uint32_t label);

            /*! \brief Remove expired point clouds from the merged point cloud. 
             
             * @return Set of labels removed 
             * */
            std::set<std::uint32_t> removeExpiredPointClouds();

        public:
            IntraSensorManager(const std::string& topicName, double maxAge);
            ~IntraSensorManager();

            bool operator==(const IntraSensorManager& other) const;


            /*!
             * \brief Feed a PointCloud to manage.
             * This method acts as point cloud producer.
             * @param newCloud The PointCloud smart pointer.
             */
            void addCloud(pcl::PointCloud<pcl::PointXYZRGBL>::Ptr newCloud);

            /*!
             * \brief Set the transform between the sensor frame and the robot base frame.
             * @param transform
             */
            void setSensorTransform(const Eigen::Affine3d& transform);

            /*!
             * \brief Get the max age points live for after being fed.
             * @return The configured max points age.
             */
            double getMaxAge() const;

            /*! \brief Get the defined point aging callback.
             *
             * @return The defined point aging callback.
             */
            std::function<void(std::set<std::uint32_t> labels)> getPointAgingCallback() const;

            /*! \brief Set the point aging callback.
             *
             * @param func The callback to set.
             */
            void setPointAgingCallback(const std::function<void(std::set<std::uint32_t> labels)>& func);

            /*! \brief Get the defined PointCloud ready callback.
             *
             * @return The defined callback.
             */
            std::function<void(entities::StampedPointCloud cloud, std::string& sensorName)>
            getPointCloudReadyCallback() const;

            /*! \brief Set the PointCloud ready callback.
             *
             * @param func The callback to set.
             */
            void setPointCloudReadyCallback(const std::function<void(entities::StampedPointCloud cloud,
                    std::string& sensorName)>& func);

            /*! \brief Get the average time elapsed between point cloud arrival and delivery. */
            double getAverageRegistrationTime();

            /*! \brief Get the variance of the time elapsed between point cloud arrival and delivery. */
            double getVarianceRegistrationTime();

            /*! \brief Get the standard deviation of the time elapsed between point cloud arrival and delivery. */
            double getStdDevRegistrationTime();

            /*! \brief Get the number of point clouds already processed
             * This is also the number of pointclouds which already contributed to the average and variance of registration time.
             */
            size_t getSampleCount();




        /*! \brief Max age watching routine.
         *
         * This routine is ran by a thread in background watching the age of the PointClouds
         * contained in this IntraSensorManager. Whenever a thread older than the max age is found it is removed.
         *
         * @param instance Pointer to the IntraSensorManager instance
         */
        friend void maxAgeWatchingRoutine(IntraSensorManager* instance);

    };

} // pcl_aggregator::managers

#endif //PCL_AGGREGATOR_CORE_INTRASENSORMANAGER_H
